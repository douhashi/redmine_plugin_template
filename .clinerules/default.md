## はじめに

このドキュメントは、Cline がRedmineプラグインの開発を行う際のガイドラインをまとめたものです。
このガイドラインに従って、開発を行ってください。

## 参考ドキュメント

技術情報や詳細なアーキテクチャについては [ドキュメント目次](../docs/README.md) に記載があるので参考にしてください。

## 開発モードについて

以下の4つのモードを状況に応じて自動的に切り替えながら開発を行ってください。

 モード                          │ 役割                            │ 自動切替のタイミング
─────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────────
 PM                              │ 要件定義・計画作成              │ 新規機能の検討時、要件の明確化が必要な時
 Architect                       │ 設計・技術選定                  │ 実装前の設計が必要な時、技術的判断が必要な時
 Code                            │ 実装・テスト                    │ 具体的なコード作成やバグ修正時
 QA                              │ 品質管理・確認                  │ 作業完了時や品質チェックが必要な時

あなたは作業の内容や流れに応じて最適なモードを自動的に選択し、目的の達成に向けて最大効率で作業を進めてください。

## 基本ルール

• 指示に従う:
  • 要件や指示に従って作業を進める
  • 作業の進捗や問題が発生した場合は適宜報告
• 自律的な問題解決:
  • エラーや何かしらの問題が発生したら、自律的に問題分析と解決案を提示
  • 複数のアプローチがある場合は、推奨案を明示
  • ソースコード外の問題である可能性がある場合は、指示者に報告
• 既存コードの尊重:
  • 既存のコードスタイルやパターンがある場合には、それに従う
  • 大幅な変更が必要な場合は理由を説明
• 連続で修正に失敗した場合:
  • 2回以上連続でテストを失敗した時は、現在の状況を整理して指示者に報告
  • 同じことを連続で行うのではなく、問題の解決策を提案
• 学習記録の自律化:
  • タスク完了時に新しい学びがあった場合、適切なカテゴリの学習記録ファイルに自動記録
  • 2回以上同じ問題に遭遇した場合は必ず記録
  • 効率化や改善点を発見した場合も記録
  • 記録の判断基準: 技術的な新発見、開発プロセスの改善点、時間短縮につながる方法、環境固有の問題と解決策

## 学習記録の活用

実装前や問題解決時は、以下の手順で学習記録を確認してください：

1. **関連する学習記録の確認**: `.clinerules/lessons-learned/README.md` で関連する分野・問題解決パターンを確認
2. **技術分野別の参照**: 使用する技術に応じて適切なカテゴリのファイルを参照
   - 認証関連: `authentication/` ディレクトリ
   - テスト関連: `testing/` ディレクトリ  
   - UI/UX関連: `ui-ux/` ディレクトリ
   - データ管理関連: `data-management/` ディレクトリ
   - プロジェクト管理関連: `project-management/` ディレクトリ
3. **類似問題の検索**: 過去に同様の問題を解決した記録がないか確認
4. **新しい学習記録の追加**: 新しい学びは適切なカテゴリに分類して記録

### 学習記録の分類ルール

新しい学習記録を追加する際は、以下の基準で適切なカテゴリに分類してください：

- **技術分野**: 主に使用した技術・フレームワーク
- **問題領域**: 解決した問題の種類
- **影響範囲**: プロジェクト全体 vs 特定機能
- **再利用性**: 他のプロジェクトでの活用可能性

### 学習記録後の必須手順
1. 学習記録をコミット: `git add .clinerules/lessons-learned.md && git commit -m "docs: [タスク名]の学習記録を追加"`
2. リモートリポジトリにプッシュ: `git push origin [ブランチ名]`
3. 記録内容の永続化を確認

### 学習の自動実行タイミング
- プルリクエスト作成前、Issue完了コメント追加前に学習記録の確認・実行
- 重要な知見が得られたタスクの完了時
- 新しい技術パターンや解決策を発見した時
- 検証スクリプトや自動化ツールを作成した時
- 段階的改善やリファクタリングで効果的なパターンを発見した時

## セキュリティ

### 機密ファイル

以下を読み取ったり変更したりすることは絶対に避けてください。

• .env ファイル
•  config/credentials.yml.enc
•  config/master.key
•  */.pem
• API キー、トークン、認証情報を含むファイル全般

何か機密ファイルの編集が必要になった場合は、指示者に連絡してください。

また、以下のセキュリティガイドラインに従って作業を行ってください。

• 機密ファイルを絶対にコミットしない
• シークレット情報は環境変数を使用する
• ログや出力に認証情報を含めない

## 作業プロセス

以下のプロセスに従って、作業を進めます。

1. 要件理解（PMモード）
  • 要件の明確化・詳細化
  • 必要に応じて質問や提案
2. 設計（Architectモード）
  • 適切なアーキテクチャ・パターンの選択
  • コンポーネント設計・データフロー設計
3. 実装（Codeモード）
  • 設計に基づいたコーディング
  • ユニットテストの作成
4. 品質確認（QAモード）
  • コードレビュー
  • 要件充足の確認

AIはこれらのステップを自動的に判断して進め、1回のリクエストでも可能な限り完結した成果物を提供します。

### GitHub Issueワークフロー

要件/実行計画はGithubのIssueとして与えられます。
実行計画はIssueの説明やコメントに記載されている場合もあるので、コメントも含めIssueの内容を確認するようにしてください。
プロジェクトの要件管理と進捗追跡にはGitHub Issueを使用します：

1. 要件定義（PMモード）
  - GitHub Issueの内容を確認する

  GH_PAGER= gh issue view <issue番号>

  - GitHub Issue

### ブランチ命名規則

実装を開始する前に、作業内容に応じた適切な接頭辞を持つブランチを作成します：

- feat/#<issue番号>-<機能名> : 新機能追加 🚀
- fix/#<issue番号>-<バグ名> : バグ修正 🐛
- docs/#<issue番号>-<ドキュメント名> : ドキュメント更新 📚
- style/#<issue番号>-<対象名> : スタイル調整 💅
- refactor/#<issue番号>-<対象名> : リファクタリング ♻️
- test/#<issue番号>-<テスト名> : テスト追加・修正 🧪
- chore/#<issue番号>-<作業名> : 雑務的な変更 🔧

例：

- feat/#42-user-registration : ユーザー登録機能の追加
- fix/#123-login-error : ログインエラーの修正
- docs/#56-api-documentation : API ドキュメントの更新

### ブランチ作成ワークフロー

1. 実装開始前のブランチ作成
  - 実行計画が承認されたら、適切な接頭辞を持つブランチを作成
  - ブランチ名は  <接頭辞>/#<issue番号>-<簡潔な説明>  の形式にする

  # 新機能追加の場合
  git checkout -b feat/#<issue番号>-<機能名>

  # バグ修正の場合
  git checkout -b fix/#<issue番号>-<バグ名>

  # その他の例
  git checkout -b docs/#<issue番号>-<ドキュメント名>
  git checkout -b style/#<issue番号>-<対象名>
  git checkout -b refactor/#<issue番号>-<対象名>
  git checkout -b test/#<issue番号>-<テスト名>
  git checkout -b chore/#<issue番号>-<作業名>

2. ブランチ作成の記録
  - 作成したブランチをIssueにコメントとして記録

  ※ tmp以下にブランチ作成の内容を記載したファイルを作成しておく
  GH_PAGER= gh issue comment <issue番号> --body-file tmp/branch_created.md

3. 実装作業の開始
  - 作成したブランチ上で実装作業を進める
  - 定期的にコミットし、作業の進捗を記録する


### 実装からPRまでの流れ

1. ブランチの作成
  git checkout -b <接頭辞>/#<issue番号>-<簡潔な説明>

2. 実装作業
  - 実行計画に従って実装を進める
  - 小さな単位で定期的にコミット

  git add .
  git commit -m "<接頭辞>: コミットメッセージ"

3. 実装部分のテストの実行
  - 実装完了後、テスト計画に従ってテストを実行
  - パスしなかった場合はパスするまで修正をしてください

  cd /workspace/redmine && bundle exec rspec

4. フルテストの実行
  - 実装部分のテストが完了したら、フルテストを実行し、全体のテストがパスするかを確認
  - パスしなかった場合はパスするまで修正をしてください

  cd /workspace/redmine && bundle exec rspec

5. 変更のプッシュ
  git push origin <ブランチ名>

6. 学習記録の確認・実行
  - 新しい学びがあった場合、`.clinerules/lessons-learned.md` に記録
  - 技術的な新発見、開発プロセスの改善点、時間短縮につながる方法を記録
  - 学習記録をコミット・プッシュして永続化

  git add .clinerules/lessons-learned.md
  git commit -m "docs: [タスク名]の学習記録を追加"
  git push origin <ブランチ名>

7. プルリクエストの作成
  ※ PR作成前に、tmp以下にprの内容を記載したファイルを作成しておく
  gh pr create --title "<接頭辞>: PRのタイトル" --body-file tmp/pr_body.md --base main

  • 実装した機能/修正の説明

## 関連するIssue

fixes #<issue番号>

## テスト結果

  - 実行したテストの概要
  - カバレッジ情報

## レビューポイント

  - レビュアーに特に確認してほしい点


8. Issue完了報告
  • 実装完了のコメントを追加（Issueのクローズは指示者が行うため、自分でクローズしないこと）

  GH_PAGER= gh issue comment <issue番号> --body "PR #<PR番号> を作成しました。実装完了しました。"

### ghコマンド使用例

#### Issue一覧の確認

  GH_PAGER= gh issue list --state open

#### 特定のIssueの詳細確認

  GH_PAGER= gh issue view <issue番号>

#### Issueへのコメント追加

  ※ tmp以下にコメント内容を記載したファイルを作成しておく
  GH_PAGER= gh issue comment <issue番号> --body-file tmp/comment.md

#### Issueの説明欄の編集

  ※ tmp以下に新しい説明内容を記載したファイルを作成しておく
  GH_PAGER= gh issue edit <issue番号> --body-file tmp/issue_description.md

#### 既存の説明に追記する場合

  ※ tmp以下に追記内容を記載したファイルを作成しておく
  GH_PAGER= gh issue edit <issue番号> --body-file tmp/issue_description.md --append

  ## 追加内容
  追記したい内容をここに記述
  "

#### Issueのクローズ

  GH_PAGER= gh issue close <issue番号> --comment "クローズ理由"

#### 新しいIssueの作成

  GH_PAGER= gh issue create --title "Issue タイトル" --body "Issue の説明"

## 技術スタック

このプロジェクトで定義された技術スタックに従って開発を行います。
特に指定がない場合は、一般的なベストプラクティスに基づいて技術を選定します。

### バックエンド

• 言語: Ruby
• フレームワーク: Rails
• データベース: SQLite3

### 開発ツール

• リンター: Rubocop Rails Omakase
• テスト: RSpec, Capybara
• ファクトリ: Factory Bot
• CI/CD: GitHub Actions

### アプリケーション起動

• アプリケーションは localhost:3000 で起動します
• アプリケーションが起動していない場合、 `bin/rails server -b 0.0.0.0` コマンドで起動できます
• サーバーが既に起動している場合は、そのまま継続して作業してください

### その他

• バージョン管理ツール: Git
• パッケージ管理: Bundler (Ruby), npm (JavaScript)

## セキュリティガイドライン

• 機密情報（API キー、パスワードなど）はハードコーディングしない
• ユーザー入力は必ず検証する
• 環境変数を適切に使用する
•  .env  ファイルなど機密ファイルは絶対に変更しない

## コーディングガイドライン

### 一般原則

• シンプルで読みやすいコード
• 適切な命名（変数、関数、クラスなど）
• 一つの関数は一つの責務を持つ
• エラーハンドリングを適切に実装
• コメントは必要な箇所にのみ付ける

### Ruby/Rails

• Rubyのイディオムを活用する
• ActiveRecordのベストプラクティスに従う
• Fat Model, Skinny Controllerの原則を守る
• 複雑なロジックはサービスオブジェクトに抽出する

### Redmine

- Redmineに関するドキュメントは docs 以下にある
- (docs/README.md)[../docs/README.md] に目次があるので、参照して適宜必要な情報を探索すること

### テスト

• 主要機能のユニットテスト
• エッジケースの考慮
• システムテストで重要なユーザージャーニーをカバー
• テストが実行可能であることを確認

## コミットメッセージのガイドライン

簡潔かつ明確なコミットメッセージを記述することで、変更履歴を追いやすくします。

• feat: 新機能追加 🚀
• fix: バグ修正 🐛
• docs: ドキュメント更新 📚
• style: スタイル調整 💅
• refactor: リファクタリング ♻️
• test: テスト追加・修正 🧪
• chore: 雑務的な変更 🔧

### コミットの注意事項

• 1つのコミットでは1つの論理的な変更のみを含める
• 複数の変更がある場合は複数のコミットに分割する
• コミットメッセージは日本語で記述可能
• コミット前に必ず  rubocop -a  コマンドをそのまま実行してコードベース全体のコードスタイルを整える

### コミットのやり方

 git add . && git commit -m "feat: ユーザー登録機能を追加"
のようにコミットメッセージを記述してコミットしてください。

## ベストプラクティス

• 汎用的で再利用可能なコンポーネントを作成
• 基本的なパフォーマンス最適化を実装
• 基本的なアクセシビリティ対応を実装
• Core Web Vitalsを意識した実装
